# 交叉验证机制

## 触发条件

### 1. 全栈问题

**定义**：任务同时涉及前端和后端代码或逻辑。

**识别信号**：
- 涉及的文件同时包含前端和后端扩展名
- 问题描述涉及前后端交互（如 "API 调用后页面不更新"）
- 修改需要同时调整前后端代码

**示例**：
- "登录后页面白屏" - 可能是 API 问题或前端渲染问题
- "表单提交失败" - 可能是前端验证、API 处理或数据库问题
- "数据显示不正确" - 可能是 API 返回格式或前端解析问题

### 2. 高不确定性

**定义**：问题有多种可能原因，难以确定根因。

**识别信号**：
- 错误信息模糊或缺失
- 问题间歇性出现
- 初步分析后仍有多个可能原因

**示例**：
- "有时候页面加载很慢" - 可能是前端渲染、API 响应或网络问题
- "偶尔出现数据丢失" - 可能是前端状态、API 处理或数据库事务问题

### 3. 设计决策

**定义**：需要评估多种架构或技术方案。

**识别信号**：
- 任务涉及新功能设计
- 需要选择技术栈或架构模式
- 方案有多种可行选项

**示例**：
- "设计实时通知系统" - 需要评估 WebSocket/SSE + UI 展示方案
- "优化搜索功能" - 需要评估后端搜索引擎 + 前端交互体验

### 4. 复杂 Bug

**定义**：难以定位的问题，需要多角度分析。

**识别信号**：
- 常规调试方法无效
- 问题涉及多个系统组件
- 复现条件复杂

**示例**：
- "特定用户无法完成支付" - 需要检查用户状态、支付 API、前端流程
- "移动端特定操作崩溃" - 需要检查前端兼容性和后端数据处理

### 5. 关键路径修改

**定义**：影响核心功能的代码变更。

**识别信号**：
- 修改涉及认证、支付、数据安全等核心模块
- 变更影响多个下游功能
- 修改不可轻易回滚

**示例**：
- "重构用户认证流程" - 影响前端登录 UI 和后端认证逻辑
- "升级数据库 schema" - 影响后端模型和前端数据展示

## 验证流程

### 阶段 1：并行调用

同时向 Codex 和 Gemini 发送任务，各自从专业视角分析。

**Codex 任务模板**：
```
## 背景
[问题/任务描述]

## 请从后端/逻辑角度分析

重点关注：
1. API 设计和实现是否正确
2. 数据流和状态管理是否合理
3. 性能瓶颈和优化空间
4. 安全性考虑
5. 错误处理和边界情况

## 期望输出
- 分析结论
- 发现的问题（如有）
- 建议的解决方案
```

**Gemini 任务模板**：
```
## 背景
[问题/任务描述]

## 请从前端/UI 角度分析

重点关注：
1. 组件结构和渲染逻辑是否正确
2. 用户交互和体验是否流畅
3. 状态管理是否合理
4. 样式和响应式设计
5. 可访问性和兼容性

## 期望输出
- 分析结论
- 发现的问题（如有）
- 建议的解决方案
```

### 阶段 2：结果对比

收集两个模型的输出后，进行对比分析：

```
┌─────────────────────────────────────────┐
│           结果对比分析                   │
├─────────────────────────────────────────┤
│                                         │
│  Codex 结论        Gemini 结论          │
│      │                 │                │
│      └────────┬────────┘                │
│               │                         │
│         对比分析                         │
│               │                         │
│      ┌────────┴────────┐                │
│      │                 │                │
│   一致点            分歧点               │
│      │                 │                │
│      ▼                 ▼                │
│   直接采纳        Claude 仲裁           │
│                                         │
└─────────────────────────────────────────┘
```

### 阶段 3：综合结论

**一致情况**：
- 两个模型结论一致 → 直接采纳
- 记录一致结论，继续流程

**分歧情况**：
- 两个模型结论不同 → Claude 仲裁
- 分析分歧原因
- 结合两方观点给出最终结论
- 必要时进行额外验证

## 输出格式

### 标准交叉验证报告

```markdown
## 交叉验证报告

### 验证背景
- **触发原因**: [全栈问题/高不确定性/设计决策/复杂bug/关键修改]
- **验证范围**: [涉及的文件/模块]

### Codex 分析（后端视角）

#### 分析结论
[Codex 的主要结论]

#### 发现的问题
1. [问题1]
2. [问题2]

#### 建议方案
[Codex 建议的解决方案]

### Gemini 分析（前端视角）

#### 分析结论
[Gemini 的主要结论]

#### 发现的问题
1. [问题1]
2. [问题2]

#### 建议方案
[Gemini 建议的解决方案]

### 综合结论

#### 一致点
- [两者一致的发现1]
- [两者一致的发现2]

#### 分歧点
| 方面 | Codex 观点 | Gemini 观点 | 仲裁结论 |
|------|-----------|-------------|---------|
| [方面1] | [观点] | [观点] | [结论] |

#### 最终建议
[Claude 综合两方分析后的最终建议]

#### 后续行动
1. [行动1]
2. [行动2]
```

## 质量保证

### 验证结果的可信度评估

| 情况 | 可信度 | 处理方式 |
|------|--------|---------|
| 两者一致，证据充分 | 高 | 直接采纳 |
| 两者一致，证据不足 | 中 | 补充验证 |
| 两者分歧，各有道理 | 中 | Claude 仲裁 |
| 两者分歧，一方明显错误 | 低（错误方） | 采纳正确方 |
| 两者都不确定 | 低 | 需要更多信息 |

### 常见分歧处理

1. **技术选型分歧**
   - 评估各方案的优缺点
   - 结合项目实际情况选择

2. **问题定位分歧**
   - 两个方向都进行验证
   - 用证据确定真正原因

3. **方案优先级分歧**
   - 评估影响范围和实施成本
   - 选择性价比最高的方案

## 性能考虑

### 并行调用优化

- 两个模型调用应并行执行，减少等待时间
- 使用 `&` 后台执行或并行工具

### 超时处理

- 单个模型调用超时：使用已完成的结果 + Claude 补充
- 两个都超时：回退到 Claude 独立分析

### 成本控制

- 只在必要时触发交叉验证
- 简单问题不需要双模型验证
- 记录验证历史，避免重复验证相同问题
