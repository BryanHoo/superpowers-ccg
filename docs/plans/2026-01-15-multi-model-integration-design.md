# Superpowers 多模型融合设计

**日期**: 2026-01-15
**状态**: 已批准
**版本**: 1.0

---

## 1. 概述

### 1.1 目标

将 ccg-workflow 的多模型调用能力（codeagent-wrapper）融入 superpowers skills，实现：

- 以 superpowers 方法论为主体框架
- 自动路由任务到最适合的模型（Codex/Gemini）
- 复杂场景智能触发交叉验证

### 1.2 设计原则

1. **用户无感知** - 自动路由，无需手动指定模型
2. **方法论优先** - skills 的流程和规范不变，多模型作为增强能力
3. **智能判断** - Claude 综合多因素决定路由和交叉验证
4. **渐进增强** - 多模型调用是可选增强，不影响基础功能

---

## 2. 架构设计

### 2.1 分层架构

```
┌─────────────────────────────────────────────────────────┐
│                  Superpowers Skills                      │
│  (brainstorming, debugging, TDD, code-review, etc.)     │
│                     [方法论层]                           │
└─────────────────────────┬───────────────────────────────┘
                          │ 引用
                          ▼
┌─────────────────────────────────────────────────────────┐
│               multi-model-core                           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │
│  │  路由判断   │ │ 交叉验证    │ │ 结果整合    │       │
│  └─────────────┘ └─────────────┘ └─────────────┘       │
│                     [调用层]                             │
└─────────────────────────┬───────────────────────────────┘
                          │ 调用
                          ▼
┌─────────────────────────────────────────────────────────┐
│               codeagent-wrapper                          │
│         ┌─────────────┐    ┌─────────────┐              │
│         │   Codex     │    │   Gemini    │              │
│         │  (后端/逻辑) │    │  (前端/UI)  │              │
│         └─────────────┘    └─────────────┘              │
│                     [执行层]                             │
└─────────────────────────────────────────────────────────┘
```

### 2.2 调用流程

```
用户任务
    │
    ▼
Skill 流程执行
    │
    ├─── 需要外部模型辅助？
    │         │
    │         ├─ 否 → 继续 Claude 处理
    │         │
    │         └─ 是 → 调用 multi-model-core
    │                      │
    │                      ▼
    │               综合判断路由
    │                      │
    │         ┌────────────┼────────────┐
    │         ▼            ▼            ▼
    │      Codex        Gemini      交叉验证
    │      (后端)       (前端)      (双模型)
    │         │            │            │
    │         └────────────┴────────────┘
    │                      │
    │                      ▼
    │               结果整合返回
    │                      │
    └──────────────────────┘
                │
                ▼
          继续 Skill 流程
```

---

## 3. 路由规则

### 3.1 综合判断因素

路由判断综合以下因素，由 Claude 智能决策：

#### 3.1.1 文件类型

| 模型 | 文件扩展名 |
|------|-----------|
| Gemini | `.tsx`, `.jsx`, `.vue`, `.svelte`, `.css`, `.scss`, `.less`, `.html`, `.astro` |
| Codex | `.go`, `.py`, `.java`, `.rs`, `.rb`, `.php`, `.sql`, `.sh`, `.c`, `.cpp` |
| 智能判断 | `.ts`, `.js`, `.json`, `.yaml`, `.md` (根据上下文) |

#### 3.1.2 目录结构

| 模型 | 目录模式 |
|------|---------|
| Gemini | `*/components/*`, `*/pages/*`, `*/views/*`, `*/styles/*`, `*/ui/*`, `*/frontend/*`, `*/web/*` |
| Codex | `*/server/*`, `*/api/*`, `*/services/*`, `*/backend/*`, `*/cmd/*`, `*/internal/*`, `*/pkg/*` |

#### 3.1.3 任务关键词

| 模型 | 关键词 |
|------|-------|
| Gemini | UI, 样式, 组件, 布局, 动画, 响应式, CSS, 交互, 用户体验, 视觉, 前端 |
| Codex | API, 数据库, 算法, 性能, 并发, 安全, 后端, 服务, 逻辑, 架构, 优化 |

### 3.2 路由决策矩阵

```
                    前端特征强    前端特征弱
                   ┌────────────┬────────────┐
后端特征强         │  交叉验证   │   Codex    │
                   ├────────────┼────────────┤
后端特征弱         │   Gemini   │   Claude   │
                   └────────────┴────────────┘
```

---

## 4. 交叉验证机制

### 4.1 触发条件

Claude 根据以下条件智能判断是否触发交叉验证：

1. **全栈问题** - 任务同时涉及前端和后端
2. **高不确定性** - 问题有多种可能原因，难以确定
3. **设计决策** - 需要评估多种架构方案
4. **复杂 bug** - 难以定位的问题，需要多角度分析
5. **关键路径** - 影响核心功能的修改

### 4.2 交叉验证流程

```
触发交叉验证
      │
      ▼
┌─────────────────────────────────────┐
│  并行调用 Codex 和 Gemini           │
│  ┌─────────────┐  ┌─────────────┐  │
│  │   Codex     │  │   Gemini    │  │
│  │  后端视角   │  │  前端视角   │  │
│  └──────┬──────┘  └──────┬──────┘  │
│         │                │         │
│         └────────┬───────┘         │
│                  ▼                 │
│           结果对比分析              │
└─────────────────┬───────────────────┘
                  │
                  ▼
        ┌─────────────────┐
        │  结论一致？      │
        └────────┬────────┘
                 │
        ┌────────┴────────┐
        ▼                 ▼
      一致              分歧
        │                 │
        ▼                 ▼
    采纳结论         Claude 仲裁
                          │
                          ▼
                    综合两方观点
                    给出最终结论
```

### 4.3 结果整合规范

交叉验证结果整合格式：

```markdown
## 交叉验证结果

### Codex 分析（后端视角）
[Codex 的分析结果]

### Gemini 分析（前端视角）
[Gemini 的分析结果]

### 综合结论
- **一致点**: [两者一致的结论]
- **分歧点**: [存在分歧的地方]
- **最终建议**: [Claude 综合判断后的建议]
```

---

## 5. 模块设计

### 5.1 multi-model-core 模块

**位置**: `skills/multi-model-core/SKILL.md`

**职责**:
- 定义路由规则和判断逻辑
- 定义交叉验证触发条件
- 提供调用模板
- 定义结果整合规范

**内容结构**:
```
skills/multi-model-core/
├── SKILL.md              # 主文件：使用指南和规则
├── routing-rules.md      # 路由规则详细定义
├── cross-validation.md   # 交叉验证机制
└── prompts/              # 调用模板
    ├── codex-base.md     # Codex 基础提示词
    └── gemini-base.md    # Gemini 基础提示词
```

### 5.2 Skills 修改清单

| Skill | 修改内容 | 多模型应用场景 |
|-------|---------|---------------|
| `systematic-debugging` | 添加多模型诊断阶段 | 根因分析时双模型交叉诊断 |
| `brainstorming` | 添加方案评估多模型验证 | 设计方案评估时多视角验证 |
| `writing-plans` | 添加技术方案多模型辅助 | 技术细节设计时专业模型辅助 |
| `executing-plans` | 添加任务路由逻辑 | 实施阶段按任务类型路由到专业模型 |
| `subagent-driven-development` | 添加子任务分发逻辑 | 子任务按前后端特征分发 |
| `requesting-code-review` | 添加双模型审查 | 代码审查时双模型交叉审查 |
| `test-driven-development` | 添加测试生成路由 | 测试生成按技术栈路由 |
| `verification-before-completion` | 添加交叉确认 | 验证阶段交叉确认 |
| `dispatching-parallel-agents` | 添加模型选择逻辑 | 并行任务按特征分配模型 |

---

## 6. 调用规范

### 6.1 codeagent-wrapper 调用语法

```bash
codeagent-wrapper --backend <codex|gemini> - [工作目录] <<'EOF'
<任务内容>
EOF
```

### 6.2 调用模板

#### 6.2.1 单模型调用

```markdown
## 调用外部模型

根据任务特征，路由到 {模型名称}：

**路由依据**:
- 文件类型: {涉及的文件}
- 任务关键词: {识别到的关键词}
- 目录特征: {涉及的目录}

**任务描述**:
{具体任务内容}

**期望输出**:
{期望的输出格式}
```

#### 6.2.2 交叉验证调用

```markdown
## 触发交叉验证

**触发原因**: {触发条件}

### 任务描述
{具体任务内容}

### Codex 任务（后端视角）
请从后端/逻辑角度分析：
{针对 Codex 的具体问题}

### Gemini 任务（前端视角）
请从前端/UI 角度分析：
{针对 Gemini 的具体问题}
```

---

## 7. 实施计划

### Phase 1: 基础模块

1. 创建 `skills/multi-model-core/` 目录结构
2. 编写 `SKILL.md` 主文件
3. 编写 `routing-rules.md` 路由规则
4. 编写 `cross-validation.md` 交叉验证机制
5. 创建基础提示词模板

### Phase 2: 核心 Skills 修改

1. 修改 `systematic-debugging` - 添加多模型诊断
2. 修改 `brainstorming` - 添加方案评估验证
3. 修改 `writing-plans` - 添加技术方案辅助
4. 修改 `executing-plans` - 添加任务路由

### Phase 3: 扩展 Skills 修改

5. 修改 `subagent-driven-development` - 添加子任务分发
6. 修改 `requesting-code-review` - 添加双模型审查
7. 修改 `test-driven-development` - 添加测试路由
8. 修改 `verification-before-completion` - 添加交叉确认
9. 修改 `dispatching-parallel-agents` - 添加模型选择

### Phase 4: 验证与文档

10. 测试各 skill 的多模型调用
11. 更新 `using-superpowers` 说明
12. 编写使用示例

---

## 8. 示例场景

### 8.1 调试场景

**用户**: "登录后页面白屏"

**systematic-debugging 流程**:
1. 收集信息 → 发现涉及前端渲染和后端 API
2. 触发交叉验证（全栈问题）
3. Codex 分析：检查 API 响应、认证逻辑
4. Gemini 分析：检查组件渲染、状态管理
5. 综合结论：API 返回格式变更导致前端解析失败

### 8.2 设计场景

**用户**: "设计一个实时通知系统"

**brainstorming 流程**:
1. 理解需求 → 涉及前后端
2. 方案探索 → 触发交叉验证（设计决策）
3. Codex 视角：WebSocket vs SSE、消息队列选型
4. Gemini 视角：通知 UI 组件、动画效果、用户体验
5. 综合方案：技术选型 + UI 设计一体化方案

### 8.3 代码审查场景

**用户**: "审查这个 PR"

**requesting-code-review 流程**:
1. 分析变更 → 涉及 API 和组件
2. 触发双模型审查
3. Codex 审查：API 设计、安全性、性能
4. Gemini 审查：组件结构、样式、可访问性
5. 综合报告：合并两方审查意见

---

## 9. 注意事项

1. **降级处理** - 如果 codeagent-wrapper 不可用，skill 应能正常运行（仅用 Claude）
2. **超时控制** - 外部模型调用应有合理超时，避免阻塞
3. **结果验证** - Claude 应验证外部模型返回结果的合理性
4. **隐私考虑** - 敏感代码应谨慎发送给外部模型

---

## 10. 附录

### 10.1 相关文件

- `ccg-workflow/codeagent-wrapper/` - wrapper 源码
- `ccg-workflow/templates/prompts/` - 现有提示词模板
- `skills/` - superpowers skills 目录

### 10.2 参考资料

- ccg-workflow README
- superpowers skills 文档
